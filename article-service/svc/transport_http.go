// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: ef2331b7e2
// Version Date: 2020-10-07T23:22:38Z

package svc

// This file provides server-side bindings for the HTTP transport.
// It utilizes the transport/http.Server.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"

	"context"

	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pkg/errors"

	// This service
	pb "article"
)

const contentType = "application/json; charset=utf-8"

var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = pb.NewArticleClient
	_ = io.Copy
	_ = errors.Wrap
)

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(endpoints Endpoints, options ...httptransport.ServerOption) http.Handler {
	serverOptions := []httptransport.ServerOption{
		httptransport.ServerBefore(headersToContext),
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerAfter(httptransport.SetContentType(contentType)),
	}
	serverOptions = append(serverOptions, options...)
	m := mux.NewRouter()

	m.Methods("GET").Path("/detail/").Handler(httptransport.NewServer(
		endpoints.DetailEndpoint,
		DecodeHTTPDetailZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("GET").Path("/detail").Handler(httptransport.NewServer(
		endpoints.DetailEndpoint,
		DecodeHTTPDetailOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("GET").Path("/records/").Handler(httptransport.NewServer(
		endpoints.RecordsEndpoint,
		DecodeHTTPRecordsZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("GET").Path("/records").Handler(httptransport.NewServer(
		endpoints.RecordsEndpoint,
		DecodeHTTPRecordsOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("GET").Path("/remove/").Handler(httptransport.NewServer(
		endpoints.RemoveEndpoint,
		DecodeHTTPRemoveZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("GET").Path("/remove").Handler(httptransport.NewServer(
		endpoints.RemoveEndpoint,
		DecodeHTTPRemoveOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("GET").Path("/top/").Handler(httptransport.NewServer(
		endpoints.TopEndpoint,
		DecodeHTTPTopZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("GET").Path("/top").Handler(httptransport.NewServer(
		endpoints.TopEndpoint,
		DecodeHTTPTopOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("GET").Path("/recommends/").Handler(httptransport.NewServer(
		endpoints.RecommendsEndpoint,
		DecodeHTTPRecommendsZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("GET").Path("/recommends").Handler(httptransport.NewServer(
		endpoints.RecommendsEndpoint,
		DecodeHTTPRecommendsOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("GET").Path("/review/").Handler(httptransport.NewServer(
		endpoints.ReviewEndpoint,
		DecodeHTTPReviewZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	m.Methods("GET").Path("/review").Handler(httptransport.NewServer(
		endpoints.ReviewEndpoint,
		DecodeHTTPReviewOneRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("POST").Path("/publish").Handler(httptransport.NewServer(
		endpoints.PublishEndpoint,
		DecodeHTTPPublishZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Methods("POST").Path("/edit").Handler(httptransport.NewServer(
		endpoints.EditEndpoint,
		DecodeHTTPEditZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	return m
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	body, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			body = jsonBody
		}
	}
	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(httptransport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	w.Write(body)
}

type errorWrapper struct {
	Error string `json:"error"`
}

// httpError satisfies the Headerer and StatusCoder interfaces in
// package github.com/go-kit/kit/transport/http.
type httpError struct {
	error
	statusCode int
	headers    map[string][]string
}

func (h httpError) StatusCode() int {
	return h.statusCode
}

func (h httpError) Headers() http.Header {
	return h.headers
}

// Server Decode

// DecodeHTTPDetailZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded detail request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDetailZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DetailRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdDetailStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdDetailStr := ArticleIdDetailStrArr[0]
		ArticleIdDetail := ArticleIdDetailStr
		req.ArticleId = ArticleIdDetail
	}

	return &req, err
}

// DecodeHTTPDetailOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded detail request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDetailOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.DetailRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdDetailStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdDetailStr := ArticleIdDetailStrArr[0]
		ArticleIdDetail := ArticleIdDetailStr
		req.ArticleId = ArticleIdDetail
	}

	return &req, err
}

// DecodeHTTPRecordsZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded records request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPRecordsZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.RecordsRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CategoryIdRecordsStrArr, ok := queryParams["category_id"]; ok {
		CategoryIdRecordsStr := CategoryIdRecordsStrArr[0]
		CategoryIdRecords := CategoryIdRecordsStr
		req.CategoryId = CategoryIdRecords
	}

	if TagIdRecordsStrArr, ok := queryParams["tag_id"]; ok {
		TagIdRecordsStr := TagIdRecordsStrArr[0]
		TagIdRecords := TagIdRecordsStr
		req.TagId = TagIdRecords
	}

	if TypeRecordsStrArr, ok := queryParams["type"]; ok {
		TypeRecordsStr := TypeRecordsStrArr[0]
		TypeRecords := TypeRecordsStr
		req.Type = TypeRecords
	}

	if PageRecordsStrArr, ok := queryParams["page"]; ok {
		PageRecordsStr := PageRecordsStrArr[0]
		PageRecords, err := strconv.ParseInt(PageRecordsStr, 10, 32)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting PageRecords from query, queryParams: %v", queryParams))
		}
		req.Page = int32(PageRecords)
	}

	if SortTypeRecordsStrArr, ok := queryParams["sort_type"]; ok {
		SortTypeRecordsStr := SortTypeRecordsStrArr[0]
		SortTypeRecords := SortTypeRecordsStr
		req.SortType = SortTypeRecords
	}

	return &req, err
}

// DecodeHTTPRecordsOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded records request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPRecordsOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.RecordsRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CategoryIdRecordsStrArr, ok := queryParams["category_id"]; ok {
		CategoryIdRecordsStr := CategoryIdRecordsStrArr[0]
		CategoryIdRecords := CategoryIdRecordsStr
		req.CategoryId = CategoryIdRecords
	}

	if TagIdRecordsStrArr, ok := queryParams["tag_id"]; ok {
		TagIdRecordsStr := TagIdRecordsStrArr[0]
		TagIdRecords := TagIdRecordsStr
		req.TagId = TagIdRecords
	}

	if TypeRecordsStrArr, ok := queryParams["type"]; ok {
		TypeRecordsStr := TypeRecordsStrArr[0]
		TypeRecords := TypeRecordsStr
		req.Type = TypeRecords
	}

	if PageRecordsStrArr, ok := queryParams["page"]; ok {
		PageRecordsStr := PageRecordsStrArr[0]
		PageRecords, err := strconv.ParseInt(PageRecordsStr, 10, 32)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting PageRecords from query, queryParams: %v", queryParams))
		}
		req.Page = int32(PageRecords)
	}

	if SortTypeRecordsStrArr, ok := queryParams["sort_type"]; ok {
		SortTypeRecordsStr := SortTypeRecordsStrArr[0]
		SortTypeRecords := SortTypeRecordsStr
		req.SortType = SortTypeRecords
	}

	return &req, err
}

// DecodeHTTPRemoveZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded remove request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPRemoveZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.RemoveRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdRemoveStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdRemoveStr := ArticleIdRemoveStrArr[0]
		ArticleIdRemove := ArticleIdRemoveStr
		req.ArticleId = ArticleIdRemove
	}

	return &req, err
}

// DecodeHTTPRemoveOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded remove request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPRemoveOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.RemoveRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdRemoveStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdRemoveStr := ArticleIdRemoveStrArr[0]
		ArticleIdRemove := ArticleIdRemoveStr
		req.ArticleId = ArticleIdRemove
	}

	return &req, err
}

// DecodeHTTPTopZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded top request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTopZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TopRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdTopStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdTopStr := ArticleIdTopStrArr[0]
		ArticleIdTop := ArticleIdTopStr
		req.ArticleId = ArticleIdTop
	}

	return &req, err
}

// DecodeHTTPTopOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded top request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTopOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TopRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdTopStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdTopStr := ArticleIdTopStrArr[0]
		ArticleIdTop := ArticleIdTopStr
		req.ArticleId = ArticleIdTop
	}

	return &req, err
}

// DecodeHTTPRecommendsZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded recommends request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPRecommendsZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.RecommendsRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CategoryIdRecommendsStrArr, ok := queryParams["category_id"]; ok {
		CategoryIdRecommendsStr := CategoryIdRecommendsStrArr[0]
		CategoryIdRecommends := CategoryIdRecommendsStr
		req.CategoryId = CategoryIdRecommends
	}

	if TagIdRecommendsStrArr, ok := queryParams["tag_id"]; ok {
		TagIdRecommendsStr := TagIdRecommendsStrArr[0]
		TagIdRecommends := TagIdRecommendsStr
		req.TagId = TagIdRecommends
	}

	if TypeRecommendsStrArr, ok := queryParams["type"]; ok {
		TypeRecommendsStr := TypeRecommendsStrArr[0]
		TypeRecommends := TypeRecommendsStr
		req.Type = TypeRecommends
	}

	if PageRecommendsStrArr, ok := queryParams["page"]; ok {
		PageRecommendsStr := PageRecommendsStrArr[0]
		PageRecommends, err := strconv.ParseInt(PageRecommendsStr, 10, 32)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting PageRecommends from query, queryParams: %v", queryParams))
		}
		req.Page = int32(PageRecommends)
	}

	if SortTypeRecommendsStrArr, ok := queryParams["sort_type"]; ok {
		SortTypeRecommendsStr := SortTypeRecommendsStrArr[0]
		SortTypeRecommends := SortTypeRecommendsStr
		req.SortType = SortTypeRecommends
	}

	return &req, err
}

// DecodeHTTPRecommendsOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded recommends request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPRecommendsOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.RecommendsRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if CategoryIdRecommendsStrArr, ok := queryParams["category_id"]; ok {
		CategoryIdRecommendsStr := CategoryIdRecommendsStrArr[0]
		CategoryIdRecommends := CategoryIdRecommendsStr
		req.CategoryId = CategoryIdRecommends
	}

	if TagIdRecommendsStrArr, ok := queryParams["tag_id"]; ok {
		TagIdRecommendsStr := TagIdRecommendsStrArr[0]
		TagIdRecommends := TagIdRecommendsStr
		req.TagId = TagIdRecommends
	}

	if TypeRecommendsStrArr, ok := queryParams["type"]; ok {
		TypeRecommendsStr := TypeRecommendsStrArr[0]
		TypeRecommends := TypeRecommendsStr
		req.Type = TypeRecommends
	}

	if PageRecommendsStrArr, ok := queryParams["page"]; ok {
		PageRecommendsStr := PageRecommendsStrArr[0]
		PageRecommends, err := strconv.ParseInt(PageRecommendsStr, 10, 32)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting PageRecommends from query, queryParams: %v", queryParams))
		}
		req.Page = int32(PageRecommends)
	}

	if SortTypeRecommendsStrArr, ok := queryParams["sort_type"]; ok {
		SortTypeRecommendsStr := SortTypeRecommendsStrArr[0]
		SortTypeRecommends := SortTypeRecommendsStr
		req.SortType = SortTypeRecommends
	}

	return &req, err
}

// DecodeHTTPReviewZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded review request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReviewZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReviewRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdReviewStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdReviewStr := ArticleIdReviewStrArr[0]
		ArticleIdReview := ArticleIdReviewStr
		req.ArticleId = ArticleIdReview
	}

	return &req, err
}

// DecodeHTTPReviewOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded review request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPReviewOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ReviewRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ArticleIdReviewStrArr, ok := queryParams["article_id"]; ok {
		ArticleIdReviewStr := ArticleIdReviewStrArr[0]
		ArticleIdReview := ArticleIdReviewStr
		req.ArticleId = ArticleIdReview
	}

	return &req, err
}

// DecodeHTTPPublishZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded publish request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPublishZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.PublishRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPEditZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded edit request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPEditZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.EditRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	marshaller := jsonpb.Marshaler{
		EmitDefaults: false,
		OrigName:     true,
	}

	return marshaller.Marshal(w, response.(proto.Message))
}

// Helper functions

func headersToContext(ctx context.Context, r *http.Request) context.Context {
	for k := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "request-url", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}
